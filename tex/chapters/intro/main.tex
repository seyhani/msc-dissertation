% !TeX root=../main.tex
\chapter{مقدمه}
در شبکه‌های کامپیوتری رفتار اجزای شبکه‌ را می‌توان در یکی از این دو دسته قرار داد:
سطح کنترل%
\lf{Control Plane}
 و سطح داده%
\lf{Data Plane}.
در سطح کنترل تصمیم‌گیری در مورد چگونگی رسیدگی به ترافیک شبکه انجام می‌شود، مثلا چه پورت‌هایی باید باز شوند یا چه نوع بسته‌هایی اجازه‌ی عبور دارند.
در سطح داده، رفتار‌هایی که در سطح کنترل در مورد آن‌ها تصمیم‌گیری شده‌است صرفا اجرا می‌شوند. 
مثلا باز کردن پورت‌ها یا عبور دادن بسته‌هایی از یک نوع خاص 
رفتار‌هایی هستند که در سطح داده طبقه‌‌بندی می‌شوند.
در شبکه‌های کامپیوتری فعلی رفتار‌های این دو سطح در اجزای شبکه تجمیع شده‌اند.
به همین دلیل یک شبکه‌ی کامپیوتری عملا یک سیستم توزیع شده‌ شامل برنامه‌هایی است که برای هر یک از اجزای شبکه به شکل مجزا نوشته شده است و این مساله باعث پیچیدگی شبکه‌ و مدیریت آن‌‌ می‌شود
\cite{sdn-survey}.
شبکه‌های مبتنی بر نرم‌افزار%
\lf{Software Defined Network}
برای حل این مشکل از یک نرم‌افزار متمرکز برای کل‌ شبکه استفاده می‌کنند.
به طور دقیق‌تر، در شبکه‌های مبتنی بر نرم‌افزار، رفتار‌های سطح کنترل و داده از یکدیگر جدا می‌شوند. 
در نتیجه‌ی این جداسازی اجزای شبکه مانند سوییچ‌ها یا روترها دستگاه‌های ساده‌ای در نظر گرفته می‌شوند که تنها رفتار‌های سطح داده دارند و رفتار‌های سطح کنترل توسط یک نرم‌افزار متمرکز انجام می‌شود.
بنابراین، در یک شبکه‌ی مبتنی بر نرم‌افزار، مدیر شبکه یک برنامه برای مدیریت کل شبکه می‌نویسد و دیگر نیازی به برنامه‌نویسی برای تک تک اجزای شبکه ندارد.

با توجه به نقش حیاتی شبکه‌ها در سیستم‌های کامپیوتری، اطمینان از عملکرد درست آن‌ها از اهمیت بالایی برخوردار است 
\cite{foerster2018survey}.
روش‌های صوری%
\lf{Formal Methods}
مجموعه‌ای از زبان‌های مبتنی بر ریاضی، تکنیک‌ها و ابزار‌هایی برای توصیف و درستی‌سنجی سیستم‌های سخت‌افزاری و نرم‌افزاری هستند
\cite{clarke1996formal}.
شبکه‌های مبتنی بر نرم‌افزار با متمرکز کردن رفتار کنترل‌کننده‌ی شبکه و ساده‌تر کردن اجزای دیگر شبکه امکان به کار گیری چنین روش‌هایی را تسهیل کرده‌اند.
روش‌های متعددی مانند
\cite{al2010flowchecker,khurshid2013veriflow,not-nice,zeng2014libra}
برای درستی‌سنجی شبکه‌های مبتنی بر نرم‌افزار ارائه شده‌اند.

OpenFlow
\cite{mckeown2008openflow}
مطرح‌ترین رابط برنامه‌نویسی%
\lf{Application Programming Interface}
برای شبکه‌های مبتنی بر نرم‌افزار است.
اما برنامه‌های نوشته شده با 
OpenFlow
معمولا سطح پایین هستند و کار کردن با آن‌ها برای کاربر معمولا دشوار است. 
به همین دلیل زبان‌های برنامه‌نویسی متعددی مانند
\cite{foster2011frenetic,voellmy2011nettle,netcore,procera,pyretic,netkat}
ارائه شده‌اند
که با استفاده از 
OpenFlow
امکان برنامه‌نویسی برای شبکه‌های مبتنی بر نرم‌افزار در سطح بالاتر را فراهم می‌کنند.
نت‌کت یکی از این زبان‌ها است%
\lf{NetKAT} \cite{netkat} که بر پایه‌ی
KAT \cite{kat}
بنا شده است.
استفاده از 
KAT
و داشتن یک سیستم معادلاتی صحیح%
\lf{Sound}
و کامل%
\lf{Complete}
باعث می‌شود تا اثبات درستی برنامه‌ها در نت‌کت را بتوان با روش‌های جبری و اثبات تساوی برنامه‌های مختلف توصیف شده در این زبان انجام داد.
نت‌کت پویا%
\lf{DyNetKAT}\cite{dynetkat}
برای بهبود برخی از قابلیت‌های نت‌کت ارائه شده است که از جمله این قابلیت‌ها می‌توان به امکان توصیف به‌روز رسانی‌های شبکه و استدلال در مورد چندین بسته در شبکه اشاره کرد.

در درستی‌سنجی نرم‌افزار با روش‌های صوری یک مدل از سیستم و رفتار 
مورد انتظار آن در قالب یک مدل ریاضی توصیف می‌شود و با روش‌هایی مبتنی بر الگوریتم، مانند وارسی مدل%
\lf{Model Checking} \cite{clarke1997model}،
می‌توان ثابت کرد که سیستم با رفتار مورد انتظار تطابق دارد یا خیر.
یکی از مهم‌ترین ویژگی‌های الگوریتم‌های درستی‌سنجی امکان تولید مثال‌نقض‌%
\lf{Counterexample}
یا گواهی%
\lf{Certificate}
برای اثبات نقض رفتار مورد انتظار توسط سیستم است.
این مثال‌نقض‌ یا گواهی‌ها با اینکه می‌توانند در مورد رفتار سیستم توضیح دهند ولی درک درستی از این که چرا ویژگی مورد نظر در سیستم نقض شده است به دست نمی‌دهند.
به دست آوردن چنین درکی از اینکه چرا سیستم به درستی و مطابق انتظار کار نمی‌کند به آنالیز و تحلیلی فراتر نیاز دارد.
استفاده از علیت%
\lf{Causality}
و پیدا کردن علت خطا
یکی از راهکار‌ها برای به دست آوردن درک بیشتر از مشکل سیستم است.
مفهوم علیت و مبانی آن قرن‌ها در متون فلسفه مورد مطالعه قرار گرفته و استدلال مبتنی بر خلاف واقع%
\lf{Counterfactual Reasoning}
روشی است که در نهایت برای پیدا کردن علت واقعی مورد استفاده قرار گرفته است.
با وجود اینکه چنین نظریه‌ای مدت‌ها پیش مورد توافق قرار گرفته است، فرمولاسیون دقیق ریاضی آن در سال‌های اخیر توسط هالپرن%
\lf{Joseph Y. Halpern}
و پرل%
\lf{Judea Pearl}
در 
\cite{hp}
ارائه شده است \cite{explications}.
این مدل از علت واقعی در چندین پژوهش مانند 
\cite{Caltais-LTL,causal-hml,causality-checking,chockler}
 مورد استفاده قرار گرفته است تا علت واقعی خطا در سیستم پیدا شود. 
\begin{figure}
    \centering
    \begin{tikzpicture}[node distance={25mm},main/.style = {draw, circle,minimum size=8mm}]
        \node[main] (a)  {$a$};
        \node[main] (b) [above of=a]  {$b$};
        \node[main] (c) [left of=b] {$c$};
        \node[main] (d)  [below of=c] {$d$};
        \draw [->,green,thick] (a) -- (b);
        \draw [->,green,thick] (b) edge[bend right] (c);
        \draw [->,orange,thick] (c) -- (d);
        \draw [->,green,thick,dashed] (a) -- (c);
        \draw [->,orange,thick,dashed] (c) -- (b);
        \draw [->,orange,thick,dashed] (b) -- (d);
        \draw pic["$\alpha$",
        draw=blue,->,thick,angle eccentricity=1.2,
        angle radius=1.2cm] {angle=b--a--c} ;
        \draw pic["$\beta$",
        draw=blue,<-,thick,angle eccentricity=1.5,
        angle radius=1.2cm] {angle=b--c--d} ;
    \end{tikzpicture}
    \caption{
        به‌روز رسانی 
        $\alpha$
        مسیر سبز پر رنگ‌ را با مسیر خط‌چین جایگزین می‌کند.
        به‌روز رسانی
        $\beta$
        مسیر نارنجی پر رنگ را با مسیر خط‌چین جایگزین می‌کند.
     }
    \label{fig:intro:example}
\end{figure}
 هدف پژوهش جاری استفاده از این مدل علیت برای پیدا کردن علت نقض 
ویژگی در برنامه‌های توصیف شده با زبان نت‌کت پویا است.
به عنوان مثال شبکه‌ی شکل 
\ref{fig:intro:example}
را در نظر بگیرید.
در این شبکه یک مسیر از 
$a$
به 
$d$
وجود دارد و نیاز است تا این مسیر به روز رسانی شود تا ابتدا از سوییچ 
$c$
عبور کند. 
برای این منظور دو به روز رسانی 
$\alpha$
و
$\beta$
در شبکه انجام می‌شوند که به ترتیب مسیرهای سبز و نارنجی پر رنگ را با مسیر‌های خط‌چین جایگزین می‌کنند.
پس از اجرای هر دو به‌روز رسانی مسیر جدیدی از 
$a$
به 
$d$
ایجاد می‌شود.
فرض کنید که به‌روز رسانی‌ها به گونه‌ای انجام شوند که ابتدا 
$\beta$
و سپس
$\alpha$
انجام شود. 
در این حالت پس از اجرای اولین به‌روز رسانی یک دور%
\lf{Loop}
شامل سوییچ‌های 
$b$
و 
$c$
به وجود می‌آید.
نبود دور یکی از ویژگی‌های رایجی است که در شبکه‌های کامپیوتری مورد بررسی قرار می‌گیرد
\cite{network-abstractions}.
بنابراین اگر برنامه‌ی این شبکه به گونه‌ای توصیف شده باشد که امکان انجام به‌روز رسانی‌ها به این شکل را داشته باشد، این شبکه ویژگی بدون دور بودن را نقض می‌کند.
با توجه به ساده بودن این مثال در اینجا به سادگی می‌توان دریافت که انجام شدن 
$\beta$
پیش 
$\alpha$
علت خطا بوده است.
هدف پژوهش جاری پیدا کردن چنین عواملی به عنوان علت خطا در شبکه‌های مبتنی بر نرم‌افزار است.

زبان نت‌کت پویا، چون بر پایه‌ی نت‌کت بنا شده‌است،
در کنار حفظ ساختار مینیمال و ساده‌ی خود امکان توصیف به‌روز رسانی‌های شبکه‌ را هم فراهم می‌کند
و با توجه به اینکه به‌روز رسانی‌های شبکه منشا مهمی برای بروز خطا در شبکه هستند، از این زبان در این پژوهش استفاده شده است.
در این پژوهش سعی شده است تا رویکرد متفاوتی نسبت به پژوهش‌هایی مانند
\cite{causality-checking,causal-hml,decomposing}
اتخاذ شود.
اولا در این پژوهش روابط ساختاری عملیات‌ها،
مثلا هم‌روندی یا تقدم و تاخر آن‌ها، به عنوان علت در نظر گرفته می‌شوند.
ثانیا در این پژوهش به صورت مستقیم از تعریف علت واقعی مطابق
\cite{hp}
استفاده می‌شود.
برای رسیدن به دو هدف ذکر شده از ساختمان رویداد%
\lf{Event Structure} \cite{es}
به عنوان مدل معنایی برنامه‌های توصیف شده در نت‌کت پویا استفاده شده است.
ساختمان رویداد یک مدل محاسباتی%
\lf{Computational Model}
برای پردازه‌های هم‌روند است.
در مدل‌های برگ‌برگ شده%
\lf{Interleaving}
مانند سیستم انتقال%
\lf{Transition System}
هم‌روندی پردازه‌ها به صورت صریح توصیف نمی‌شود و با انتخاب غیرقطعی%
\lf{Non-Deterministic Choice}
بین ترتیب‌های ممکن اجرای آن‌ها جایگزین می‌شود.
اما ساختمان رویداد یک مدل غیر برگ‌برگ شده%
\lf{Non-Interleaving}
 است که در آن هم‌روندی پردازه‌ها به صورت صریح توصیف می‌شود.
استفاده از این مدل کمک می‌کند که هم‌روندی عملیات‌ها هم بتواند به عنوان علت خطا در نظر گرفته شود، امری که با استفاده از مدل‌های برگ‌برگ شده ممکن نیست. 

به صورت خلاصه برای پیدا کردن علت خطا در یک برنامه‌ی نت‌کت پویا ابتدا، با استفاده از مدل‌ معنایی، ساختمان رویداد معادل برنامه محاسبه می‌شود. 
سپس یک مدل علّی%
\lf{Causal Model}
 بر اساس معادلات ساختاری%
\lf{Strucutral Equations}
که در 
\cite{hp}
از آن استفاده شده است ساخته می‌شود.
در نهایت با توصیف کردن رفتار نا امن%
\lf{Unsafe Behavior}
در مدل علّی
 و با استفاده از تعریف علت واقعی هالپرن و پرل، علت واقعی رفتار نا امن پیدا می‌شود.
در مثال شکل 
\ref{fig:intro:example}
با استفاده از این روش می‌توان نبود این شرط در سیستم که الزاما به‌روز رسانی 
$\beta$
پس از 
$\alpha$
انجام شود را به عنوان علت واقعی به وجود آمدن دور در شبکه معرفی کرد.

\section{ساختار فصل‌ها}
در فصل دوم تعاریف و دانش پیش‌زمینه‌ی مورد نیاز برای بقیه فصول 
بیان می‌شود.
 در فصل سوم مروری بر کار‌های پیشین و مرتبط با این پژوهش انجام می‌شود.
فصل چهارم روش ساخت یک مدل علّی از نقض ویژگی در یک برنامه‌ی توصیف شده در زبان نت‌کت پویا
بیان می‌شود.
سپس به کار گیری روش ارائه شده در این پژوهش برای پیدا کردن علت خطا در چند دسته از ویژگی‌های رایج شبکه مورد بررسی قرار می‌گیرد. در این فصل بررسی می‌شود که علت واقعی پیدا شده تا چه میزان با شهود موجود از مساله تطابق دارد و این فرمولاسیون تا چه حد موفق عمل می‌کند.
در نهایت فصل پنجم شامل جمع‌بندی کار‌های انجام شده در این پژوهش و بحث در مورد کاستی‌های آن و کار‌های پیش‌رو است.

