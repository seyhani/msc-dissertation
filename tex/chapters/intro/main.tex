% !TeX root=../main.tex
\chapter{مقدمه}
در شبکه‌های کامپیوتری رفتار اجزای شبکه‌ را می‌توان در یکی از این دو دسته قرار داد:
سطح کنترل
\lf{Control Plane}
 و سطح داده
\lf{Data Plane}.
در سطح کنترل تصمیم‌گیری در مورد چگونگی رسیدگی به ترافیک انجام می‌شود، مثلا چه پورت‌هایی باید باز شوند یا چه نوع بسته‌هایی اجازه‌ی عبور دارند.
در سطح داده، رفتار‌هایی که در سطح کنترل تصمیم‌گیری شده است اجرا می‌شود. 
مثلا باز کردن پورت‌ها یا عبور دادن بسته‌هایی از یک نوع خاص 
رفتار‌هایی هستند که در سطح داده طبقه‌‌بندی می‌شوند.
در شبکه‌های کامپیوتری فعلی رفتار‌های این دو سطح در اجزای شبکه تجمیع شده‌اند.
به همین دلیل یک شبکه‌ی کامپیوتری عملا یک سیستم توزیع شده‌است که شامل برنامه‌هایی است که برای هر یک از اجزای شبکه به شکل مجزا نوشته شده است و این شبکه‌ها به وضوح پیچیده هستند و مدیریت آن‌ها دشوار است
\cite{sdn-survey}.
شبکه‌های مبتنی بر نرم‌افزار
\lf{Software Defined Network}
برای حل این مشکل از یک نرم‌افزار متمرکز برای کل‌ شبکه استفاده می‌کنند.
به طور دقیق‌تر، در شبکه‌های مبتنی بر نرم‌افزار، رفتار‌های سطح کنترل و داده از یکدیگر جدا می‌شوند. 
در نتیجه‌ی این جداسازی اجزای شبکه مانند سوییچ‌ها یا روترها دستگاه‌های ساده‌ای در نظر گرفته می‌شوند که تنها رفتار‌های سطح داده دارند و رفتار‌های سطح کنترل توسط یک نرم‌افزار متمرکز توصیف می‌شود.
بنابراین، در یک شبکه‌ی مبتنی بر نرم‌افزار، مدیر شبکه یک برنامه برای مدیریت کل شبکه می‌نویسد و دیگر نیازی به برنامه‌نویسی برای تک تک اجزای شبکه ندارد.

OpenFlow
\cite{mckeown2008openflow}
مطرح‌ترین رابط برنامه‌نویسی
\lf{Application Programming Interface}
برای شبکه‌های مبتنی بر نرم‌افزار است.
اما برنامه‌های نوشته شده با 
OpenFlow
معمولا سطح پایین هستند و کار کردن با آن‌ها برای کاربر معمولا دشوار است. 
به همین دلیل زبان‌های برنامه‌نویسی متعددی مانند
\cite{foster2011frenetic,voellmy2011nettle,netcore,procera,pyretic,netkat}
که با استفاده از 
OpenFlow
امکان برنامه‌نویسی برای شبکه‌های مبتنی بر نرم‌افزار در سطح بالاتر را فراهم می‌کنند.

با توجه به نقش حیاتی شبکه‌ها در سیستم‌های کامپیوتری، اطمینان از عملکرد درست آن‌ها از اهمیت بالایی برخوردار است 
\cite{foerster2018survey}.
روش‌های صوری
\lf{Formal Methods}
مجموعه‌ای از زبان‌های مبتنی بر ریاضی، تکنیک‌ها و ابزار‌هایی برای توصیف و درستی‌سنجی سیستم‌های سخت‌افزاری و نرم‌افزاری هستند
\cite{clarke1996formal}.
شبکه‌های مبتنی بر نرم‌افزار با متمرکز کردن رفتار کنترل‌کننده‌ی شبکه و ساده‌تر کردن اجزای دیگر شبکه امکان به کار گیری چنین روش‌هایی را تسهیل کرده‌اند.
روش‌های متعددی مانند
\cite{al2010flowchecker,khurshid2013veriflow,not-nice,zeng2014libra}
برای درستی‌سنجی شبکه‌های مبتنی بر نرم‌افزار ارائه شده‌اند.

نت‌کت
\lf{NetKAT} \cite{netkat}
یک زبان برنامه‌نویسی شبکه‌های مبتنی بر نرم‌افزار است که بر پایه‌ی
KAT \cite{kat}
بنا شده است.
استفاده از 
KAT
و داشتن یک سیستم معادلاتی صحیح
\lf{Sound}
و کامل
\lf{Complete}
باعث می‌شود تا اثبات درستی برنامه‌ها در نت‌کت را بتوان با روش‌های جبری و اثبات تساوی برنامه‌های مختلف توصیف شده در این زبان انجام داد.
نت‌کت پویا
\lf{DyNetKAT}\cite{dynetkat}
برای بهبود برخی از قابلیت‌های نت‌کت ارائه شده است که از جمله این قابلیت‌ها می‌توان به امکان توصیف به‌روز رسانی‌های شبکه و استدلال در مورد چندین بسته در شبکه اشاره کرد.
در درستی‌سنجی نرم‌افزار با روش‌های صوری یک مدل از سیستم و رفتار مورد انتظار آن توصیف می‌شود و با روش‌هایی مبتنی بر الگوریتم مانند وارسی مدل
\lf{Model Checking} \cite{clarke1997model}
می‌توان ثابت کرد که سیستم با رفتار مورد انتظار تطابق دارد یا خیر

یکی از مهم‌ترین ویژگی‌های این الگوریتم‌ها امکان تولید مثال‌نقض
\lf{Counterexample}
یا گواهی
\lf{Certificate}
برای اثبات نقض رفتار مورد انتظار توسط سیستم را دارند.
این مثال‌نقض‌ یا گواهی‌ها با اینکه می‌توانند در مورد رفتار سیستم توضیح دهند ولی درک درستی از این که چرا ویژگی مورد نظر در سیستم نقض شده است نمی‌دهند.
به دست آوردن چنین درکی از اینکه چرا سیستم به درستی و مطابق انتظار کار نمی‌کند به آنالیز و تحلیلی فراتر نیاز دارد.
استفاده از علیت
\lf{Causality}
یکی از راهکار‌ها برای به دست آوردن درک بیشتر از مشکل سیستم است.
مفهوم علیت و مبانی آن قرن‌ها در متون فلسفه مورد مطالعه قرار گرفته و استدلال مبتنی بر خلاف واقع روشی است که در نهایت برای پیدا کردن علت واقعی مورد استفاده قرار گرفته است.
با وجود اینکه چنین نظریه‌ای مدت‌ها پیش مورد توافق قرار گرفته است، فرمولاسیون دقیق ریاضی آن در سال‌های اخیر توسط هالپرن
\lf{Joseph Y. Halpern}
و پرل
\lf{Judea Pearl}
در 
\cite{hp}
ارائه شده است \cite{explications}.
به صورت خلاصه در 
\cite{hp}
سیستم توسط متغیر‌ها و معادلات میان آن‌ها مدل می‌شود و شرایطی تعریف می‌شوند که تحت آن علت واقعی رویداد‌ها پیدا می‌شوند.
 

شبکه‌های کامپیوتری یکی از مهم‌ترین اجزای زیرساخت سیستم‌های کامپیوتری هستند
\cite{foerster2018survey}.
شبکه‌های مبتنی بر نرم‌افزار
\lf{Software Defined Network}
با متمرکز کردن رفتار کنترل‌کننده‌ی شبکه و ساده‌تر کردن عناصر شبکه در سطح داده
\lf{Data Plane}
تست و درستی‌سنجی شبکه‌ها را تسهیل کرده‌اند.
با این وجود به دلیل اینکه هر شبکه‌‌ی کامپیوتری ذاتا یک سیستم توزیع‌شده و  ناهمگام
\lf{Asynchronous}
است
اطمینان از درستی شبکه‌های مبتنی بر نرم‌افزار همچنان فرآیندی پیچیده و سخت است.
اما این همه‌ی ماجرا نیست.
درستی‌سنجی
\lf{Verification}
و تست یک شبکه‌ی مبتنی بر نرم‌افزار یا به طور کلی یک نرم‌افزار کامپیوتری قدم اول در فرآیند اشکال‌زدایی
\lf{Debug}
آن است.
روش‌های درستی‌سنجی نرم‌افزار در صورتی که سیستم مورد آزمون ویژگی
\lf{Property}
مورد نظر را برآورده نکند یک مثال‌نقض
\lf{Counterexample}
پیدا کرده و کاربر بر می‌گردانند.
به جز این مثال نقض اطلاعات دیگری به کاربر داده نمی‌شود و در نتیجه برای رفع مشکل سیستم کاربر مجبور است تا با روش‌های ابتکاری و با استفاده از دانش و شهود خود در مورد سیستم منشا مشکل را پیدا، آن را برطرف و فرآیند درستی‌سنجی را تکرار کند.
انگیزه اصلی این پژوهش جایگزین کردن بخش انسانی این فرآیند با روش‌های خودکار است.
در واقع در این پژوهش به دنبال پیدا کردن علت واقعی رخ‌دادن خطا در یک شبکه‌ی مبتنی بر نرم‌افزار هستیم.
\begin{figure}
    \centering
    \begin{tikzpicture}[
            node distance={30mm},
            main/.style = {draw, circle, minimum width=10mm},
            s/.style = {->,thick},
            d/.style = {dashed} ]
        \node[main] (b) {$b$};
        \node[main] (a) [above right of=b] {$a$};
        \node[main] (c) [below right of=a] {$c$};
        \node[main] (d) [right of=c] {$d$};
        % \node[main] (e) [left of=b] {$e$};
        % \node[main] (f) [left of=a] {$f$};
        \draw[green,s] (a) -- (b);
        \draw[green,s,d] (a) -- (c);
        \draw[orange,s,d] (c) -- (b);
        \draw[orange,s] (c) -- (d);
        % \draw[red,s] (b) -- (e);
        % \draw[red,s,d] (b) -- (f);
        \draw pic["$\alpha$",
        draw=blue,->,thick,angle eccentricity=1.2,angle radius=1.2cm] {angle=b--a--c} ;
        \draw pic["$\beta$",
        draw=blue,<-,thick,angle eccentricity=1.5,angle radius=1.2cm] {angle=b--c--d} ;
        % \draw pic["$\gamma$",
        % draw=blue,<-,thick,angle eccentricity=1.5,angle radius=1.2cm] {angle=f--b--e} ;
    \end{tikzpicture}
    \caption{ }
    \label{fig:blacklist:consistent}
\end{figure}

به عنوان مثال شبکه‌ی رسم‌شده در شکل
\ref{fig:blacklist:consistent}
را در نظر بگیرید.
در این شبکه امکان انجام دو به‌روز رسانی 
$\alpha$
و
$\beta$
وجود دارد که به ترتیب مسیر‌های سبز و نارنجی پر رنگ‌ را با مسیر‌های خط‌چین جایگزین ‌می‌کنند.
فرض کنید که ویژگی مورد انتظار در این شبکه نرسیدن بسته‌a
\lf{Packet}
ای از 
$a$
به
$d$
باشد.
پس از درستی‌سنجی می‌توان به مثال نقضی برای این ویژگی دست‌یافت که در آن ابتدا 
به روزرسانی 
$\alpha$
انجام می‌شود و سپس یک بسته از 
$a$
به 
$d$
ارسال می‌شود.
این مثال نقض ساده و کوچک است ولی در نگاه اول و بدون بررسی بیشتر کمک چندانی به اشکال‌زدایی این شبکه نمی‌کند.
با بررسی بیشتر این شبکه می‌توان دریافت که انجام شدن به روز رسانی
$\alpha$
پیش از تکمیل شدن به روز رسانی
$\beta$
سبب به وجود آمدن مسیر بین 
$a$
و
$d$
و در نتیجه بروز خطا می‌شود.
هدف از انجام این پژوهش پیدا کردن چنین عواملی 
(مثلا در اینجا ترتیب رخ‌دادن به‌روز رسانی‌ها)
به عنوان علت واقعی رخ دادن خطا است.

\section{اهداف پژوهش}
شبکه‌های مبتنی بر نرم‌افزار به دلیل اینکه ذاتا توزیع‌شده و ناهمگام هستند مورد استفاده‌ی خوبی برای پیدا کردن علت واقعی خطا و تسهیل فرآیند رفع اشکال هستند. 
به همین دلیل در این پژوهش این دامنه از مسائل مورد بررسی قرار گرفته‌اند.
برای توصیف این شبکه‌ها از زبان نت‌کت پویا
\lf{DyNetKAT} \cite{dynetkat}
استفاده شده است که یک زبان مینیمال و ساده بر پایه‌ی زبان نت‌کت
\lf{NetKAT} \cite{netkat}
که توصیف به‌روز‌ رسانی‌های شبکه و استدلال در مورد چندین بسته موجود در شبکه را فراهم کرده است.
هدف اصلی این پژوهش ارائه‌ی یک فرمولاسیون از علت واقعی
\lf{Actual Cause}
بر اساس تعریف ارائه شده در
\cite{hp}
برای برنامه‌های توصیف شده در زبان نت‌کت پویا و بررسی کارایی علت‌های واقعی پیدا شده در فرآیند اشکال‌زدایی از شبکه است.

\section{ساختار فصل‌ها}
در فصل دوم تعاریف و دانش پیش‌زمینه‌ی مورد نیاز برای بقیه فصول بیان می‌شود.
فصل سوم روش ترجمه‌ی یک برنامه‌ی توصیف شده در زبان نت‌کت پویا به یک مدل علّی
\lf{Causal Model}
بیان می‌شود.
فصل چهارم شامل به کار گیری روش ارائه شده در این پژوهش برای پیدا کردن علت خطا در چند دسته از ویژگی‌های رایج در شبکه است. در این فصل بررسی می‌شود که علت واقعی پیدا شده تا چه میزان با شهود موجود از مساله تطابق دارد و این فرمولاسیون تا چه حد موفق عمل می‌کند.
فصل پنج شامل جمع‌بندی کار‌های انجام شده در این پژوهش و بحث در مورد کاستی‌های آن و کار‌های پیش‌رو است.
در نهایت در فصل ششم مروری بر کار‌های پیشین و مرتبط با این پژوهش انجام شده است.